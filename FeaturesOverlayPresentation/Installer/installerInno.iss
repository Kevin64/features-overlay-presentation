; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

; GENERIC INSTALLER

#define MyAppName "FOP"
#define MyAppVersion GetVersionNumbersString('..\bin\Release\FOP.exe')
#define MyAppPublisher "Kevin Vinícius Teixeira Costa"
#define MyAppURL "https://github.com/Kevin64/features-overlay-presentation"
#define MyAppExeName "FOP.exe"
#define RegKey "Software\FOP"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{774C846A-339E-4668-9AB4-78D769F29CAB}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName}-{#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
CreateAppDir=yes
DefaultDirName={autopf}\{#MyAppName}
DisableDirPage=yes
; Uncomment the following line to run in non administrative install mode (install for current user only.)
;PrivilegesRequired=lowest
;PrivilegesRequiredOverridesAllowed=dialog
OutputBaseFilename=FOPsetup-v{#MyAppVersion}
OutputDir=..\bin\zip\github
Compression=lzma
SolidCompression=yes
WizardStyle=modern
UninstallDisplayIcon={app}\{#MyAppExeName}
VersionInfoVersion={#MyAppVersion}
MinVersion=6.1sp1

[Languages]
Name: "brazilianportuguese"; MessagesFile: "compiler:Languages\BrazilianPortuguese.isl"

[Dirs]
Name: "{app}\resources"
Name: "{app}\pt"

[Files]
Source: "..\bin\Release\BCrypt.Net-Next.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\Constants.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\INIFileParser.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\JsonFileReader.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\LogGenerator.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\Microsoft.Xaml.Behaviors.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\Newtonsoft.Json.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\Octokit.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\System.Memory.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\System.Numerics.Vectors.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\System.Buffers.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\System.Runtime.CompilerServices.Unsafe.dll"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\FOP.exe.config"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\FOP.exe"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\definitions.ini"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

Source: "..\bin\Release\pt\*"; DestDir: "{commonpf32}\{#MyAppName}\pt"; Flags: ignoreversion recursesubdirs createallsubdirs

Source: "..\bin\Release\resources\*"; DestDir: "{commonpf32}\{#MyAppName}\resources"; Flags: ignoreversion recursesubdirs createallsubdirs

Source: "..\bin\Release\FOP.lnk"; DestDir: "{commondesktop}"; Flags: ignoreversion

Source: "..\bin\Release\FOP.lnk"; DestDir: "{commonprograms}\"; Flags: ignoreversion

Source: "..\bin\Release\FOP.lnk"; DestDir: "{commonpf32}\{#MyAppName}"; Flags: ignoreversion

; NOTE: Don't use "Flags: ignoreversion" on any shared system files

;[Registry]
;Root: HKCU; Subkey: "Software\Microsoft\Windows\CurrentVersion\RunOnce"; ValueType: string; ValueName: FOP; ValueData: "{commonpf32}\{#MyAppName}\Rever tutorial de uso do computador.lnk"; Flags: uninsdeletekeyifempty

[Registry]
Root: HKCU; Subkey: "Software\FOP"; ValueType: DWORD; ValueName: DidItRunAlready; ValueData: "1"; Flags: uninsdeletekeyifempty

[UninstallDelete]
Type: filesandordirs; Name: "{commonpf32}\{#MyAppName}"

[Code]

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
begin
  if CurUninstallStep = usPostUninstall then
  begin
    if RegKeyExists(HKEY_CURRENT_USER, '{#RegKey}') then
        RegDeleteKeyIncludingSubkeys(HKEY_CURRENT_USER, '{#RegKey}');
  end;
end;

{ ///////////////////////////////////////////////////////////////////// }
function GetUninstallString(): String;
var
  sUnInstPath: String;
  sUnInstallString: String;
begin
  sUnInstPath := ExpandConstant('Software\Microsoft\Windows\CurrentVersion\Uninstall\{#emit SetupSetting("AppId")}_is1');
  sUnInstallString := '';
  if not RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString) then
    RegQueryStringValue(HKCU, sUnInstPath, 'UninstallString', sUnInstallString);
  Result := sUnInstallString;
end;


{ ///////////////////////////////////////////////////////////////////// }
function IsUpgrade(): Boolean;
begin
  Result := (GetUninstallString() <> '');
end;


{ ///////////////////////////////////////////////////////////////////// }
function UnInstallOldVersion(): Integer;
var
  sUnInstallString: String;
  iResultCode: Integer;
begin
{ Return Values: }
{ 1 - uninstall string is empty }
{ 2 - error executing the UnInstallString }
{ 3 - successfully executed the UnInstallString }

  { default return value }
  Result := 0;

  { get the uninstall string of the old app }
  sUnInstallString := GetUninstallString();
  if sUnInstallString <> '' then begin
    sUnInstallString := RemoveQuotes(sUnInstallString);
    if Exec(sUnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then
      Result := 3
    else
      Result := 2;
  end else
    Result := 1;
end;

{ ///////////////////////////////////////////////////////////////////// }
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if (CurStep=ssInstall) then
  begin
    if (IsUpgrade()) then
    begin
      UnInstallOldVersion();
    end;
  end;
end;

{ ///////////////////////////////////////////////////////////////////// }
function IsDotNetDetected(): boolean;
var
    key: string;
    install, release: cardinal;
    success: boolean;
begin
    key := 'SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full'
    
    // success: true if the registry has been read successfully
    success := RegQueryDWordValue(HKLM, key, 'Install', install);
    success := success and RegQueryDWordValue(HKLM, key, 'Release', release);

    // install = 1 if framework is installed
    // 461808 -> .NET 4.7.2 461814 before Win10 April 2018 Update
    // 528040 -> .NET 4.8 528040
    // see https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed
    // for details
    result := success and (install = 1) and (release >= 528040);
end;

function InitializeSetup(): Boolean;
begin
    if not IsDotNetDetected() then begin
        MsgBox('Este programa requer o Microsoft .NET Framework 4.8 ou superior.'#13#13
            'Por favor, instale-o e execute este programa novamente.', mbInformation, MB_OK);
        result := false;
    end else
        result := true;
end;

const
  GWL_WNDPROC = -4;
  SB_VERT = 1;
  SB_BOTTOM = 7;
  WM_VSCROLL = $0115;
  WM_ERASEBKGND = $0014;

type
  WPARAM = UINT_PTR;
  LPARAM = LongInt;
  LRESULT = LongInt;

var
  OldStatusLabelWndProc: LongInt;
  OldFilenameLabelWndProc: LongInt;
  OldProgressListBoxWndProc: LongInt;
  ProgressListBox: TNewListBox;
  PrevStatus: string;
  PrevFileName: string;

function CallWindowProc(
  lpPrevWndFunc: LongInt; hWnd: HWND; Msg: UINT; wParam: WPARAM;
  lParam: LPARAM): LRESULT; external 'CallWindowProcW@user32.dll stdcall';  
function SetWindowLong(hWnd: HWND; nIndex: Integer; dwNewLong: LongInt): LongInt;
  external 'SetWindowLongW@user32.dll stdcall';

procedure AddProgress(S: string);
begin
  if S <> '' then
  begin
    ProgressListBox.Items.Add(S);
    ProgressListBox.ItemIndex := ProgressListBox.Items.Count;
    SendMessage(ProgressListBox.Handle, WM_VSCROLL, SB_BOTTOM, 0);
  end;
end;

function StatusLabelWndProc(
  hwnd: HWND; uMsg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT;
begin
  Result := CallWindowProc(OldStatusLabelWndProc, hwnd, uMsg, wParam, lParam);
  if PrevStatus <> WizardForm.StatusLabel.Caption then
  begin
    AddProgress(WizardForm.StatusLabel.Caption);
    PrevStatus := WizardForm.StatusLabel.Caption;
  end;
end;

function FilenameLabelWndProc(
  hwnd: HWND; uMsg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT;
begin
  Result := CallWindowProc(OldFilenameLabelWndProc, hwnd, uMsg, wParam, lParam);
  if PrevFileName <> WizardForm.FilenameLabel.Caption then
  begin
    AddProgress(WizardForm.FilenameLabel.Caption);
    PrevFileName := WizardForm.FilenameLabel.Caption;
  end;
end;

function ProgressListBoxWndProc(
  hwnd: HWND; uMsg: UINT; wParam: WPARAM; lParam: LPARAM): LRESULT;
begin
  // reduce flicker
  if uMsg = WM_ERASEBKGND then
  begin
    Result := 1;
  end
    else
  begin
    Result := CallWindowProc(OldProgressListBoxWndProc, hwnd, uMsg, wParam, lParam);
  end;
end;

procedure InitializeWizard();
begin
  OldStatusLabelWndProc :=
    SetWindowLong(WizardForm.StatusLabel.Handle, GWL_WNDPROC,
      CreateCallback(@StatusLabelWndProc));
  OldFilenameLabelWndProc :=
    SetWindowLong(WizardForm.FilenameLabel.Handle, GWL_WNDPROC,
      CreateCallback(@FilenameLabelWndProc));

  WizardForm.ProgressGauge.Top := WizardForm.FilenameLabel.Top;

  ProgressListBox := TNewListBox.Create(WizardForm);
  ProgressListBox.Parent := WizardForm.ProgressGauge.Parent;
  ProgressListBox.Top :=
    WizardForm.ProgressGauge.Top + WizardForm.ProgressGauge.Height + ScaleY(8);
  ProgressListBox.Width := WizardForm.FilenameLabel.Width;
  ProgressListBox.Height :=
    ProgressListBox.Parent.ClientHeight - ProgressListBox.Top - ScaleY(16);
  ProgressListBox.Anchors := [akLeft, akTop, akRight, akBottom];
  OldProgressListBoxWndProc :=
    SetWindowLong(ProgressListBox.Handle, GWL_WNDPROC,
      CreateCallback(@ProgressListBoxWndProc));
  // Lame way to shrink width of labels to client width of the list box,
  // so that particularly when the file paths in FilenameLabel are shortened
  // to fit to the label, they actually fit even to the list box.
  WizardForm.StatusLabel.Width := WizardForm.StatusLabel.Width - ScaleY(24);
  WizardForm.FilenameLabel.Width := WizardForm.FilenameLabel.Width - ScaleY(24);
end;

procedure DeinitializeSetup();
begin
  // In case you are using VCL styles or similar, this needs to be done before
  // you unload the style.
  SetWindowLong(WizardForm.StatusLabel.Handle, GWL_WNDPROC, OldStatusLabelWndProc);
  SetWindowLong(WizardForm.FilenameLabel.Handle, GWL_WNDPROC, OldFilenameLabelWndProc);
  SetWindowLong(ProgressListBox.Handle, GWL_WNDPROC, OldProgressListBoxWndProc);
end;